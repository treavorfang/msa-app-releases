#!/usr/bin/env python3
"""
Automatic version generator for MSA application.

Generates version information from git and build metadata.
Run this script before building/deploying the application.

Usage:
    python3 generate_version.py
"""

import subprocess
import datetime
import json
from pathlib import Path


def get_git_info():
    """Get git information."""
    try:
        # Get current commit hash
        commit_hash = subprocess.check_output(
            ['git', 'rev-parse', '--short', 'HEAD'],
            stderr=subprocess.DEVNULL
        ).decode('utf-8').strip()
        
        # Get current branch
        branch = subprocess.check_output(
            ['git', 'rev-parse', '--abbrev-ref', 'HEAD'],
            stderr=subprocess.DEVNULL
        ).decode('utf-8').strip()
        
        # Get latest tag
        try:
            tag = subprocess.check_output(
                ['git', 'describe', '--tags', '--abbrev=0'],
                stderr=subprocess.DEVNULL
            ).decode('utf-8').strip()
        except subprocess.CalledProcessError:
            tag = 'v1.0.6'  # Default if no tags
        
        # Check if working directory is clean
        is_dirty = subprocess.call(
            ['git', 'diff-index', '--quiet', 'HEAD', '--'],
            stderr=subprocess.DEVNULL
        ) != 0
        
        return {
            'commit': commit_hash,
            'branch': branch,
            'tag': tag,
            'dirty': is_dirty
        }
    except (subprocess.CalledProcessError, FileNotFoundError):
        # Git not available or not a git repository
        return {
            'commit': 'unknown',
            'branch': 'unknown',
            'tag': 'v1.0.6',
            'dirty': False
        }


def get_build_number():
    """Get or increment build number."""
    build_file = Path(__file__).parent / 'build_number.txt'
    
    if build_file.exists():
        build_number = int(build_file.read_text().strip())
    else:
        build_number = 0
    
    # Increment build number
    build_number += 1
    build_file.write_text(str(build_number))
    
    return build_number


def parse_version(tag):
    """Parse version from git tag."""
    # Remove 'v' prefix if present
    version = tag.lstrip('v')
    
    # Parse major.minor.patch
    parts = version.split('.')
    if len(parts) >= 3:
        return {
            'major': int(parts[0]),
            'minor': int(parts[1]),
            'patch': int(parts[2])
        }
    else:
        return {'major': 1, 'minor': 0, 'patch': 0}


def generate_version_file():
    """Generate version.py file with version information."""
    git_info = get_git_info()
    build_number = get_build_number()
    build_date = datetime.datetime.now()
    version_info = parse_version("v1.0.6") # Force 1.0.6 for release
    
    # Create version string
    version_string = f"{version_info['major']}.{version_info['minor']}.{version_info['patch']}"
    
    # Add build number
    full_version = f"{version_string}+build.{build_number}"
    
    # Add commit hash if dirty
    if git_info['dirty']:
        full_version += f".{git_info['commit']}.dirty"
    else:
        full_version += f".{git_info['commit']}"
    
    # Generate Python file
    version_file = Path(__file__).parent.parent / 'src' / 'app' / 'version.py'
    
    content = f'''"""
Auto-generated version information.
DO NOT EDIT THIS FILE MANUALLY!

Generated: {build_date.isoformat()}
"""

# Version components
VERSION_MAJOR = {version_info['major']}
VERSION_MINOR = {version_info['minor']}
VERSION_PATCH = {version_info['patch']}
VERSION_BUILD = {build_number}

# Version strings
VERSION = "{version_string}"
FULL_VERSION = "{full_version}"

# Git information
GIT_COMMIT = "{git_info['commit']}"
GIT_BRANCH = "{git_info['branch']}"
GIT_TAG = "{git_info['tag']}"
GIT_DIRTY = {git_info['dirty']}

# Build information
BUILD_NUMBER = {build_number}
BUILD_DATE = "{build_date.isoformat()}"
BUILD_TIMESTAMP = {int(build_date.timestamp())}

# Human-readable version
def get_version_string():
    """Get human-readable version string."""
    return VERSION

def get_full_version_string():
    """Get full version string with build info."""
    return FULL_VERSION

def get_version_info():
    """Get complete version information as dictionary."""
    return {{
        'version': VERSION,
        'full_version': FULL_VERSION,
        'major': VERSION_MAJOR,
        'minor': VERSION_MINOR,
        'patch': VERSION_PATCH,
        'build': VERSION_BUILD,
        'git_commit': GIT_COMMIT,
        'git_branch': GIT_BRANCH,
        'git_tag': GIT_TAG,
        'git_dirty': GIT_DIRTY,
        'build_date': BUILD_DATE,
        'build_timestamp': BUILD_TIMESTAMP,
    }}
'''
    
    version_file.write_text(content)
    print(f"[OK] Generated version.py: {full_version}")
    
    # Also generate JSON version file for external tools
    json_file = Path(__file__).parent.parent / 'version.json'
    version_data = {
        'version': version_string,
        'full_version': full_version,
        'major': version_info['major'],
        'minor': version_info['minor'],
        'patch': version_info['patch'],
        'build': build_number,
        'git': git_info,
        'build_date': build_date.isoformat(),
        'build_timestamp': int(build_date.timestamp()),
    }
    
    json_file.write_text(json.dumps(version_data, indent=2))
    print(f"[OK] Generated version.json")
    
    return version_data


if __name__ == '__main__':
    print("Generating version information...")
    version_data = generate_version_file()
    print(f"\nVersion: {version_data['full_version']}")
    print(f"Tag: {version_data['git']['tag']}")
    print(f"Branch: {version_data['git']['branch']}")
    print(f"Commit: {version_data['git']['commit']}")
    print(f"Build: {version_data['build']}")
    print(f"Date: {version_data['build_date']}")
    print("\nVersion generation complete!")
